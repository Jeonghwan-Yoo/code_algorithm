/*
3.6두 번째 충돌 해결 방법:체이닝
체이닝(Chaining)은 해시 테이블의 각 버킷에 하나 이상의 검색 키를 저장하는 방법입니다.
각 주소에 연결 리스트를 사용하여 충돌이 발생할 때 동적으로 여러 개의 검색 키 값을 저장할 수 있게 합니다.
1개의 버킷은 내부적으로 여러 개의 자료를 저장하고 있습니다.
보통 같은 버킷에 저장되는 자료의 단위를 슬롯(Slot)이라고 합니다.

같은 버킷의 다른 슬롯이라는 것은 계산된 해시는 같으나, 서로 다른 검색 키 값을 가진다는 뜻.
서로 다른 검색 키 값을 가지지만 같은 버킷에 저장되는 검색 키 값들을 동거자(Synonym)라고 합니다.

보통 체이닝은 연결 리스트(Linked list)를 이용하여 같은 버킷에 여러 개의 동거자가 저장할 수 있도록.
선형검색을 이용하고, 이는 연결 리스트에 저장된 자료를 하나씩 비교해 가면서 자료를 찾는 방법입니다.

체이닝에서는 새로운 자료를 추가할 때 연결 리스트의 어디에 추가할지에 따라 차이가 있습니다.
'무조건 제일 처음 저장' 혹은 '무조건 제일 마지막에 저장' 과 같은 방식. 혹은 정렬하면서.

hashingdef.h::상수와 구조체 선언
hashsearch_chain.h:체이닝을 이용한 해시 테이블의 구조체와 함수 선언
hashsearch_chain.c:체이닝을 이용한 해시 테이블 관련 함수의 구현
linkedlist.h:체이닝 구현을 위한 연결 리스트의 구조체와 함수 선언
linkedlist.c:체이닝 구현을 위한 연결 리스트의 함수 선언

3.8해시 검색의 성능 분석
해시 검색은 자료의 검색, 저장과 제거에 걸리는 시간 복잡도가 최선의 경우 O(1)이라는 훌륭한 성능.
일반적으로 전자 사전과 같이 아주 빠른 검색이 필요할 때 많이 사용.
단 충돌이 많이 발생하는 최악의 경우에는 자료 검색에 걸리는 시간 복잡도가 O(n)이 될 수도있다.
저장하는 자료의 개수나 키의 특성 등에 따라 해시 검색은 적절한 튜닝이 필요합니다.

3.8.1키 값 밀도
키 값 밀도(Key density)는 사용 가능한 전체 키 값 중에서 현재 해시 테이블에서 저장되어
실제 사용 중인 키 값의 비율을 나타냅니다.
즉, (실제 사용 중인 검색 키 값의 개수)/(사용 가능한 전체 검색 키 값의 개수)
키 값 밀도가 낮다는 의미는 특정 키 값에 데이터가 집중되어 있다는 뜻.
저장의 편중은 충돌 발생의 빈도를 상당히 증가시킵니다.
키 값 밀도가 높다는 것은 전체 해시 테이블을 골고루 사용.

3.8.2적재 밀도
적재 밀도(Loading density)는 해시 테이블에 저장할 수 있는 자료 중에서 현재 해시 테이블에
저장되어 실제 사용 중인 자료의 개수입니다.
적재 밀도(a)=(저장된 자료의 개수)/(해시 테이블에서 저장할 수 있는 전체 자료의 개수)
a=0이면 그 해시 테이블은 빈 해시 테이블입니다. 증가할수록 자료가 많이 찼다는 의미.

3.8.2.1선형 조사법
선형 조사법에서는 최대 적재 밀도가 1입니다.
즉, 자료를 저장할 수 있는 버킷과 슬롯의 개수가 한정되어 있기 떄문에 최대 밀도는 1.
실패한 경우:0.5*(1+1/(1-a)^2)
성공한 경우:0.5*(1+1/(1-a))
적재 밀도가 증가함에 따라 실패한 검색에 대한 시간 복잡도가 성공한 검색에 대한 것보다 가파르게 증가.
일반적으로 선형 조사법으로 해시 검색을 구현할 때는 적재 밀도가 0.5가 넘지 않도록 설계.

3.8.2.2체이닝
체이닝에서는 연결 리스트를 이용하기 때문에 전체 자료의 개수는 의미가 없습니다.
적재 밀도=(저장된 자료의 개수)/(해시 테이블의 버킷(연결 리스트)의 개수)
즉, 하나의 연결 리스트당 저장된 자료의 평균 개수가 됩니다.
실패한 검색:a
성공한 검색:1+a/2
검색에 실패했을 때는 모든 연결 리스트를 순회해야 하기 때문에 a가 됩니다.
체이닝에서는 선형 조사법에서 증가하는 만큼의 시간은 급속히 증가하지 않습니다.
그래도 가능한 한 낮게 유지해서 설계해야 합니다.

*/

#ifndef _HASH_DEF_
#define _HASH_DEF_
#define HASH_KEY_SIZE 10 //검색 키의 길이.

//개방 주소법과는 달리 상태를 저장할 필요 없다.
typedef struct HashSlotType {
	char key[HASH_KEY_SIZE + 1];
	int value;
}HashSlot;

#endif