/*
2.5병합 정렬(Merge sort)
기존 자료를 원소의 개수가 동일한 부분 집합으로 분할하고 분할된 각 부분 집합을 병합하면서
정렬 작업을 완성(Conquer)하는 방식으로 정렬합니다.
2개의 정렬된 자료 집합을 병합하는 경우는 2-way 병합, n개의 정렬된 자료 집합을 결합 n-way 병합.

2.5.1병합 정렬의 과정
1. 먼저 기존 자료를 원소의 개수가 동일한 여러 개의 부분 집합으로 분할해야 합니다.
2개의 부분 집합으로 나누고 다시 2개로 나누고 더 이상 나눌 자료가 없을 때까지 나눕니다.
2. 앞서 분할한 부분 집합의 자료를 합치면서 정렬을 실행하는 단계입니다.
2개씩 합치면서 최종적으로 1개의 집합을 만들어야 합니다.
그런데, 병합 정렬에서 실제 정렬이 이루어지는 시점은 2개의 부분 집합이 병합될 때 입니다.
합치려는 2개의 부분 집합의 첫 번째 원소부터 마지막 원소까지 순서대로 비교하여 키 값이 작은 자료를 선택.
주의할 점은, 병합의 대상이 되는 부분 집합 자체가 먼저 정렬이 되어 있어야 합니다.

2.5.3병합 정렬의 특성
이동 및 비교 연산이 평균적으로 O(nlog n)번 필요한 비교적 우수한 효율성을 가집니다.
이동 및 비교 연산 횟수(최선,평균,최악) : O(nlog n)
정렬 전 자료의 상태에 미치는 영향이 적다.
다만, 추가 메모리 공간이 필요하며 자료의 이동 횟수가 많습니다.
따라서, 만약 정렬 대상이 되는 자료의 크기가 큰 경우에는 시간적 낭비가 커지므로
배열 대신에 연결 리스트를 사용하여 실제 자료를 이동하는 대신 연결 포인터만을 변경하는 방식으로
물리적 이동량을 줄여서 성능을 향상시켜야 합니다.
병합 기반의 알고리즘이기 때문에 안정성이 유지됩니다.

요약
			최선		편균		최악		안정성		특징
선택 정렬	O(n^2)	O(n^2)	O(n^2)	불안정		이동 연산의 횟수 O(n)이지만 느리다.
퀵 정렬		O(nlogn)O(nlogn)O(n^2)	불안정		기존 자료의 정렬 정도에 따라 최악일수도.
병합 정렬	O(nlogn)O(nlogn)O(nlogn)안정			정렬 전 자료 상태에 미치는 영향이 적으나 추가 메모리공간이 필요하다.
*/

#ifndef _MERGE_SORT_h
#define _MERGE_SORT_h

void mergeSort(int value[], int buffer[], int start, int end);

#endif
