/*
그리디 알고리즘이라고도 합니다.
문제의 해답을 찾아가는 단계마다 욕심을 부려 선택하기 떄문입니다.
선택할 수 있는 여러 개의 대안이 있을 때 어떤 대안을 선택할 것인지 결정해야 합니다.
이 때 욕심을 부리는데 근시안적으로 의사 결정을 내린다라고도 할 수 있습니다.

문제를 풀 때 문제의 전체적인 상황을 고려하면 최적의 해답을 얻을 수 있지만, 많은 시간과 노력이 필요
탐욕 알고리즘은 전체적인 관점이 아니라 닥친 상황만 보고 결정을 내립니다.
즉, 탐욕=욕심을 부리다=눈 앞의 상황만으로 결정을 내린다=근시안적으로 선택

탐욕 알고리즘은 단계마다 그 순간에 판단할 수 있는 근거들로만 최적의 선택을 합니다.
이런 점에서 탐욕 알고리즘은 각 단계에서 결정한 선택들을 모은 것.

어렵고 복잡한 문제의 가장 좋은 답을 최적해(Optimal solution)라고 합니다.
다른 알고리즘들은 최적해를 구하기 위해서 어렵고 복잡한 방법을 이용합니다.
하지만, 탐욕 알고리즘은 굳이 최적해를 구하려고 하지 않습니다.
적당히 괜찮은 답을 찾으려고 합니다.
문제 전체를 고려하려 하지도 않고 기존 판단을 번복하지도 않습니다.

즉, 탐욕 알고리즘은 각 단계에서 최선의 선택을 하고 이들의 집합이 해가 됩니다
장점은 빠른 계산이지만 최적해를 보장하진 않습니다.

탐욕알고리즘은 단계마다 한 번 선택한 답은 이후에 변경하지 않습니다.
각 단계의 답은 별개로, 나중에 선택한 답이 이전에 선택한 답에 영향을 주지 않습니다.
답의 정확성을 포기하는 대신 빠른 계산을 선택합니다.

6.1탐욕 알고리즘의 개념
기본적인 구성요소
선택 함수(Selection function):현재 단계에서 최선의 후보를 선택
가능성 점검 함수(Feasibility function):선택된 후보가 답이 될 수 있는지 제약 사항 점검
해 판단 함수(Solution function):지금까지 선택으로 문제의 해가 완성되었는지 점검

탐욕 알고리즘은 단계별로 '선택함수'를 이용하여 최적이라고 예상되는 후보를 만듭니다.
그리고 이 후보가 가능한지 '가능성 점검 함수'를 이용하여 검증합니다. 제약사항 등
'해 판단 함수'는 지금까지의 선택들로 문제의 답이 만들어졌는지 점검합니다.

탐욕 알고리즘의 의사코드
GreedyAlgorithm(Input){
	for(Input의 모든 요소 e){
		s=SelectionFunction(e)
		if(FeasibilityFunction(s)){
			Solution<-s 추가

			if(SolutionFunction(Solution))
				return Solution;
		}
	}
	return Solution;
}

6.2동전 거스름돈 문제
동전 거스름돈 문제(Coin change problem)은 최소한의 동전을 이용하여 거스름돈을 만드는 방법을 찾는 문제.
거스름돈을 만들더라도 가능한 한 동전 개수가 적으면 적을수록 좋습니다.

예로 거스름돈으로 170원을 만드려면 여러가지가 있지만 100*1+50*1+10*2가 가장 적은 동전개수입니다.
기준은 단위가 큰 동전부터 차례로 사용하는 것입니다. 줄 수 없으면 그다음으로 큰 동전을 이용하는 것.
즉, 큰 동전부터 선택->현재 선택한 동전을 최대한 사용

6.2.1탐욕 알고리즘의 적용
GreedyAloghrithm_CoinChange()함수는 입력 파라미터로 거슬러 주어야 할 전체 금액인
change_total과 동전 종류 정보인 coins를 전달 받습니다. 각 동전 개수의 집합인 Solution을 결과로 반환.

change_total:거스름돈의 전체 금액
coins:동전들의 정보
GreedyAlgorithm_CoinChange(change_total,coins){
	Sort_coins(coins) //동전의 단위가 큰 순서대로 coins를 정렬
	for(Coins의 모든 요소 e){
		s=SelectionFunction(e) //동전 e의 최대 개수를 선택
		Solution<-s 추가 //기존 해에 동전 e의 개수를 추가
		if(SolutionFunction(Solution)) //남은 잔돈이 없으면 종료
			return Solution;
	}
	return Solution;
}
이 알고리즘이 일반적인 탐욕알고리즘과 다른 점은 동전을 큰 순서대로 먼저 정렬한다는 것입니다.
여기서 선택된 후보가 답이 될 수 있는지 제약 사항을 점검하는 가능성 점검 함수는 제외되었습니다.
왜냐하면, 선택함수 SelectionFunction() 자체가 이미 제약 사항을 고려해 계산하기 때문입니다.

실제 화폐시스템에서는 대부분 탐욕 알고리즘을 이용해 최적해를 찾습니다.
최소한의 동전 개수로 거스름돈을 만드는 탐욕 알고리즘은 항상 최적이지는 않습니다.
국가에서는 탐욕 알고리즘이 최적해가 나오도록 동전을 발행합니다.
항상 최적해를 구하려면 동적계획법을 이용하면 됩니다.

6.3부분 배낭 문제
Knapsack problem는 배낭에 어떤 물건을 효율적으로 담을지 결정하는 문제.
따라서 배낭에 담긴 물건의 총 가격이 가능한 한 높도록 물건을 선택해야 합니다.
물건에는 무게와 가격이 매겨져 있으며 가방에 담을 수 있는 전체 무게에도 제한이 있습니다.
최대한 값비싸면서 가벼운 물건을 선택해야 합니다.

부분배낭문제(Fractional knapsack problem)은 짐을 쪼갤 수 있는 경우에 배낭 문제.
부분 배낭 문제는 물건을 쪼갤 수 있는 경우에 짐의 가치가 최대가 되도록 물건을 선택하는 문제.
짐을 쪼갤 수 없는 배낭 문제를 0-1 배낭문제(0-1 knapsack problem).
물건을 아예 싣지 않거나 혹은 전체 물건을 싣기 때문.
부분 배낭 문제는 탐욕 알고리즘으로 최적해를 구할 수 있지만, 0-1배낭 문제는 구할 수 없습니다.

6.3.1탐욕 알고리즘의 적용
배낭 문제는 기본적으로 어떤 물건을 얼마만큼 담을 것인지 결정해야 합니다.
어떤 기준으로 물건들을 선택할지와 선택한 물건을 얼마만큼 담을 것인지가 핵심 내용.
결론적으로 단위 무게당 가격이 가장 비싼 물건을 골라야 합니다. (가격/무게)의 값이 가장 큰 물건부터.
그리고 가격-무게 비율을 기준으로 일단 물건을 골랐다면 담을 수 있을 만큼 최대한 담으면 됩니다.
즉, (가격/무게)가 큰 물건부터 선택->현재 선택한 물건을 최대한 담기.

GreedyAlgorithm_FractionalKnapsack()함수는 입력 파라미터로 배낭의 용량 capacity와 물건들의 정보인
items를 전달 받습니다. 함수의 계산 결과로 Solutionm을 반환. Solution은 배낭에 담긴 각 물건의 무게.

탐욕 알고리즘의 의사코드
capacity:배낭의 용량
items:물건의 정보(무게, 가격)
GreedyAlgorithm_FractionalKnapsack(capacity,items){
	Sort_items(items) //(가격/무게)비율이 큰 순서대로 items를 정렬
	for(items의 모든 요소 e){
		s=SelectionFunction(e) //물건 e를 최대한 선택
		Solution<-s추가 //기존 해에 물건 e를 추가
		if(SolitionFunction(Solution)) //배낭에 공간이 더 없으면 종료
			return Solution;
	}
	return Solution;
}
(가격/무게)비율이 큰 순서대로 먼저 정렬한다는 점이 핵심.
각 물건 e별로 현재 배낭에 담을 수 있는 최대량을 선택하여 기존 해인 Solution에 추가.
SelectionFunction()이 이미 제약 사항을 고려야 가능성 점검함수 제외.
부분해를 추가한 다음에 판단 함수 SolutionFunction을 호출하여 완성되었는지 점검.
더 이상 담을 공간이 없다면(0kg) 종료.

6.4허프만 코딩
허프만 코딩을 이해하기 위한 압축 관련 용어들
Huffman coding은 압축 알고리즘 중에서 가장 대표적.
허프만 코딩은 특별히 무손실 압축(Lossless compression) 즉, 원래 자료의 훼손 없이 압축.
자료의 정확성이 필요한 분야에서는 이러한 무손실 압축을 사용.
손실 압축(Loss compression)은 압축을 풀었을 때 자료 일부가 훼손된 압축 방식.
보통 인터넷 스트리밍 서비스 등과 같이 정확성보다는 속도가 중요한 분야에서 사용하는 방식.

압축분야에서 코딩이란 '코드로 바꾼다'는 뜻입니다. 코드란 숫자를 말합니다.
즉, 원래의 문자 기호를 숫자로 바꾸는 작업을 말합니다. 부호화라고도 합니다. 
예로 알파벳 A와 같은 문자 정보를 65와 같은 숫자로 바꾸는 것.
원래의 문자 기호로 바꾸는 것은 디코딩(Decoding)이라고 합니다. 복호화라고도 합니다.
예로 숫자 65를 원래의 문자 기호 A로 바꾸는 경우.

프로그램 분야에서 말하는 코딩은 프로그램을 만드는 작업으로 소스코드를 만드는 과정.

압축을 위한 허프만 코딩의 핵심 개념은 '기호의 빈도수'에 따른 '가변 길이 코딩'으로 요약할 수 있다.
예로 ABCDABCABA를 허프만 코딩을 이용해 압축해보겠습니다.
기호의 빈도수는 문자 기호(알파벳)이 몇 번 나오는가를 가리킵니다.
압축 분야를 제외하고 대부분의 분야에서는 '고정 길이 코드'를 사용합니다. 훨씬 편리하기 때문
아스키 코드가 대표적. 아스키 코드는 8비트로 고정되어 있습니다.
ABCDABCABA를 나타내면 (01000001 01000010 ... )로 80비트입니다.
특히 디코딩이 무척 편리합니다. 숫자의 길이가 고정되어 있기 때문에 그만큼만 읽어들이면 되기 때문.
그러나 고정 길이 코드는 저장 공간을 낭비한다는 단점이 있습니다.
자주 사용하는 문자의 길이를 짧게하면 저장 공간이 훨씬 줄어들기 때문.
즉, 자주 사용할수록 길이를 더 짧게한다면 전체 문자열의 길이는 줄어들 것입니다.

압축이란 자료가 저장되는 공간을 줄이는 작업.
허프만 코딩은 자주 나오는 문자는 길이를 짧게 하고 드물게 나오는 문자는 길이를 길게 합니다.
코딩된 문자열을 실제 사용하려면 원래의 문자열로 디코딩해야 합니다.
문자마다 길이가 다르기 때문에 고정 길이 코드보다 더 복잡한 과정.
그래서 저장공간이 절약되지만 디코딩 과정에서 사용이 불편합니다.

그러나 주의할 제약 사항이 있습니다. 코드(숫자 값)가 서로 겹치지 않아야 한다는 것.
숫자 값이 서로 달라야 글자를 구분할 수 있기 때문.
만약 A가 0이고 B가 01이면 0을 만났을 때 A인지 B인지 구분할 수가 없습니다.
접두어 코드는 가변길이 코드의 한 종류로, '한 코드가 다른 코드의 접두어가 되지 않는 코드'
즉, A:0, B:10, C:110, D:111이 가능함.

압축 대상이 되는 문자열에서는 문자의 빈도수에 따라 접두어 코드를 만들 수 있습니다.
접두어 코드로 문자열을 코딩하면 훨씬 효율적으로 저장 공간을 사용할 수 있습니다.
ABCDABCABA를 접두어 코드를 사용하면 19비트로 표현 가능합니다. 약 23% 크기로 압축.

6.4.1탐욕 알고리즘의 적용
가변 길이 코드이기 때문에 문자의 빈도수에 따라 코드의 길이가 결정됩니다.
접두어 코드이기 때문에 한 코드는 다른 코드의 시작 부분이 되어서는 안됩니다.
탐욕 알고리즘을 응용하여 허프만 트리(Huffman tree)를 만들면 됩니다.
허프만 트리 자체가 압축을 위한 도구입니다.
압축된 문자열을 원래의 문자열로 해제(디코딩)하는 방법도 알아야 합니다.

6.4.1.1허프만 트리의 생성
접두어 코드를 표현하는 이진 트리의 한 종류입니다.
왼쪽 자식 노드는 0을 주고 오른쪽 자식 노드는 1을 줍니다.
즉, 왼쪽 자식 노드를 연결하는 간선에는 0이, 오른쪽 자식 노드를 연결하는 간선에는 1이 저장됩니다.
모든 기호는 단말 노드에서만 저장이 됩니다.
허프만 트리의 단말 노드에 저장된 각 기호는 루트 노드에서의 경로를 표현합니다.
따라서 허프만 트리를 이용한 코딩이란 단말에 저장된 간선에 저장된 이진수 값으로 나타내는 것.
가변 길이 코드를 허프만 트리로 나타내면 한 코드가 다른 코드의 시작 부분이 되는 경우는 없습니다.
순환이 없는 트리를 사용하여 루트 노드부터 단말 노드까지 이르는 경로는 1가지 밖에 없기 때문.
이처럼 빈도수가 낮은 기호부터 선택하여 트리에 노드를 추가하는 방법으로 탐욕 알고리즘을 이용해
허프만 트리를 만들 수 있습니다.

Step-1
A:4 B:3 C:2 D:1에서 가장 작은 2개는 C와 D.
이 두개의 노드를 자식 노드로 가지는 부모 노드를 만듭니다. 부모 노드의 빈도수는 1+2=3이 됩니다.
새로 추가된 부모 노드(D/C) 또한 이후의 허프만 트리를 만드는 과정에 사용해야 합니다.
  D/C
   3
 /   \
D     C
1     2
Step-2
가장 빈도수가 작은 두개는 B와 D/C가 됩니다.
두 개의 노드를 자식 노드로 가지는 부모 노드를 만듭니다. B/(D/C)는 3+3=6이 됩니다.
      B/(D/C)
	    6
	 /     \
	B      D/C
	3       3
	      /   \
		 D     C
		 1     2
Step-3
다음으로 가장 빈도수가 작은 2개를 선택하면 A와 B/(D/C)
이 두개의 노드를 자식 노드로 가지는 부모 노드를 만듭니다. A/(B/(D/C))
 A/(B/(D/C))
    10
  /    \
 A	  B/(D/C)
 4		6
	 /     \
	B      D/C
	3       3
		  /   \
		 D     C
		 1     2
최종적으로 노드 1개만 남았기 때문에 완성.

GreedyAlgorithm_makeHuffmanTree()는 입력 파라미터로 코드 정보인 codes를 전달 받습니다.
codes에는 빈도수 정보가 전달되고, 처리 결과로 Solution을 반환하는데 허프만 트리가 됩니다.

허프만 트리를 만드는 탐욕 알고리즘의 의사코드
codes:각 기호별 빈도수 정보
GreedyAlgorithm_makeHuffmanTree(codes){
	for(codes의 기호 개수 -1){
		Sort_items(codes) //빈도수가 작은 순서대로 codes를 정렬
		s=SelectionFunction(codes) //빈도수가 가장 작은 기호 2개를 선택
								   //새로운 코드(부모 노드) 만들기
		codes<-s추가 //기존 코드 집합에 새로 만든 코드를 추가
	}
	Solution<-codes의 최후에 남은 코드
	return Solution;
}

6.4.1.2허프만 코딩하기
허프만 트리 자체는 이진 트리이기 때문에 코드를 찾으려면 트리 전체를 뒤져야 합니다.
비용과 시간이 많이 드는 작업입니다.
따라서 보통 허프만 트리를 만들면 허프만 코드 테이블을 만듭니다. 보통 1차원 배열의 자료구조.
그리고 각 문자를 계산한 허프만 코드를 저장합니다.
테이블을 만들면 문자를 만날 때마다 한 번의 접근을 통해 해당하는 인코딩 값을 확인할 수 있습니다.
 트리                     테이블              
 / \                      A:0
A                         B:10 
0                         C:110
   / \                    D:111
  B  
  10
     / \
    C   D
   110 111

6.4.1.3허프만 디코딩하기
문자열을 압축했으면 압축 해제도 가능해야 합니다.
기본 로직은 각 비트 값을 만날 때마다 허프만 트리에서 해당 자식 노드로 이동하는 것.
0이면 왼쪽 자식 노드, 1이면 오른쪽 자식 노드.
단말노드를 만나면 한 글자에 대해 디코딩이 끝난 상태.
이렇게 한 글자씩 디코딩을 하면서 단말 노드에 도착하면 단말 노드의 문자를 반환하고 다시 루트 노드로 이동.

ABCDABCABA를 인코딩하면 "0 10 110 111 0 10 110 0 10 0"
Step-1:첫 번째 문자 A
처음에 0을 만났습니다. 왼쪽 자식 노드는 단말 노드입니다. A를 반환하고 다시 루트노드로 이동.

Step-2~3:두 번째 문자 B
1을 만나 오른쪽 자식노드로 가고 단말노드가 아니므로 다음 비트를 읽습니다.
0을 만나 왼쪽 자식노드로 가는데 단말 노드이므로 저장된 B를 반환하고 다시 루트 노드로 이동.

Step-4~6:세 번째 문자 C
1이 3번이기 때문에 오른쪽 자식 노드로 3번이동하면 됩니다. 단말 노드 C를 만나 저장된 문자를 반환.
그리고 다시 루트 노드로 이동.

하나의 시작점에서 최단 경로를 구하는 다익스트라 알고리즘과 최소 비용 신장 트리를 구하는
크루스칼 알고리즘 및 프림 알고리즘도 탐욕 알고리즘이고 모두 최적해를 찾습니다.
각 단계에서 최선의 선택을 한다는 공통점, 각 단계의 선택이 모여서 하나의 해.

다잌스트라
선택함수:최단 거리를 알고 있는 노드 v를 선택하여 제거하고 노드 v와 연결된 노드 w를 찾아서
새로운 경로를 찾음
가능성 점검 함수:만약 노드 w를 이용하여 찾은 새로운 길이 기존에 알던 길보다 거리가 더 짧다면
노드 w의 경로를 변경
해 판단 함수:더 이상 제거할 노드가 없는지 점검.

크루스칼
선택함수:정렬된 간선 중 가중치가 가장 작으면서 순환을 발생시키지 않는 간선 e를 제거
가능성 점검 함수:순환을 발생시키면 안됨.
해 판단 함수:더 이상 제거할 간선이 없는지 점검

프림
선택함수:현재 신장 트리와 연결된 모든 간선 중에서 가장 가중치가 작은 간선을 선태갛여 신장 트리를 확장
가능성 점검 함수:순환을 발생시키면 안됨.
해 판단 함수:크래프의 모든 노드가 신장 트리에 포함되었는지 점검

*/