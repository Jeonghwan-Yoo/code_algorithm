/*
백트래킹 알고리즘(Backtracking algorithm)
백트래킹:길이 막히면 되돌아가서 다른 길로 간다.
막힌 길에서 다른 길로 되돌아간다는 개념은 미로에서 길을 찾는 문제에서 유용하게 사용할 수 있습니다.
막힌 지점에서 다른 길로 갈 수 있는 지점까지 되돌아갑니다.
백트래킹은 이렇게 해답을 찾을 때까지 되돌아가기를 반복합니다.
출구가 없는 미로라면 출구를 찾지 못하고 끝날 수도 있습니다.

구하려는 해를 얻을 때까지 모든 가능성을 시도합니다.
해답을 찾을 때까지 가능한 모든 길을 다 가보게 됩니다.
백트래킹이 해를 찾는 과정이 트리 탐색(Tree traversal) 과정과 같습니다.
결국 트리의 모든 노드를 다 순회(Traversal or Iteration)하게 됩니다.
백트래킹의 특성 때문에 전수 검사(Exhaustive search)의 한 종류라고도 합니다.

예로 
    B
   / \
  C   D
 /
D
깊이 우선 순회 방식일 경우, B->C->D가 해답이 아니라면 B까지 되돌아가서 B->D를 선택합니다.

백트래킹 알고리즘은 문제가 어려워서 특별히 효율적인 대안이 없는 경우 마지막으로 시도하는 방법.
백트래킹은 시간만 충분히 주어진다면 해답을 찾거나 혹은 해답이 없다는 것을 알 수 있습니다.
문제가 커질 경우 상당히 시간이 오래 걸립니다.
이런 문제점을 해결하는 방법으로 분기 한정법(Branch and bound) 등 탐색의 범위를 줄이는 여러 보완 방법.

9.1외판원 문제(Traveling salesman problem)
외판원 문제는 여행자 문제 혹은 순회 판매원 문제라고도 불리고 TSP라고도 합니다.
이 문제는 아직 효율적인 해결 방법이 발견되지 않은 가장 어려운 문제 중 하나.
외판원 문제는 외판원이 각 도시를 어떤 순서로 방문할지 순서를 결정하는 문제.

예로 4개의 도시가 있고, 각 도시는 서로 연결되어 있습니다. 단, 도시 사이의 거리가 서로 다릅니다.
외판원이 어떤 순서로 각각의 도시를 방문하는 것이 가장 적은 비용이 드는지 알아내는 것이 외판원 문제.
한 가지 제약 사항은, 제일 마지막에는 출발한 도시로 돌아와야 한다는 것.
즉, 도시 A에서 출발했다면 모든 도시를 방문한 뒤 다시 A로 돌아와야 합니다.
       A
	 /1|0\
  20/  B  \15
   /25/ \35\
    D-----C
      30
A->B->C->D->A를 한다면 10+35+30+20=95가 됩니다.
시작 도시로 돌아온다는 점에서 최소 비용의 사이클(Cycle)을 찾는 문제라고도 합니다.

9.1.1백트래킹의 적용
백트래킹의 기본은 길을 만드는 것. 길이 막히면 이전으로 돌아가서 다른 길을 또 만들어 보는 것.
먼저 시작 도시가 A이면, 다음 도시는 B, C, D 이렇게 모두 3개가 됩니다.
   A
  /|\
 B C D
그 다음 B를 선택했다고 합니다.

그래프를 순회(Iteration)하는 방식은 크게 깊이 우선 순회(DFS:Depth-First-Search)와
넓이 우선 순회(BFS:Breadth-First-Search) 방식.
만약 넓이 우선 순회라면 현재 노드의 형제 노드를 먼저 방문. 따라서, A->C 혹은 A->D
이 경우 경로의 길이가 아니랄 경로의 종류(가짓수)가 증가했습니다.
그러나 백트래킹은 우선 하나의 환전한 해를 만드는 것이 중요하기 때문에 특수한 경우를 제외한
대부분의 경우 깊이 우선 순회 방식을 선호합니다.
깊이 우선 탐색은 현재 노드의 자식 노드를 먼저 방문합니다. 따라서 A->B에서 A->B->C 혹은 A->B->D.
이 경우 경로의 길이가 늘어났기 때문에 하나의 완전한 해로 더 가까워지게 됩니다.
C를 선택했다고 합니다.
그러면 남은 도시가 D밖에 없기 때문에 자연스럽게 하나의 해가 만들어졌습니다.
주의할 점은 구해진 경로는 다시 시작 노드 A로 돌아가는 부분을 추가해야 합니다.
A->B->C->D->A이며 비용은 95가 됩니다.

이제 또 다른 길을 만들어야 합니다.
백트래킹에서는 되돌아가서 다른 길을 찾습니다.
B까지 돌아가서 새로운 길 A->B->D를 찾아갑니다.
이처럼 깊이 우선 탐색 방식을 통해 백트래킹을 실행함으로써 그래프의 모든 경로를 찾아서
각각의 경로마다 비용을 구하고 어떤 경우가 가장 최소의 비용을 가지는지 조사.

백트래킹 알고리즘의 의사코드
path:현재 경로(입력 파라미터)
solution:최적 경로(출력 파라미터)
시작 도시를 현재 경로 path에 먼저 추가해야합니다.
TSP_BackTracking(path, solution){
	if(path가 유효한 경로라면){
		if(path가 완전한 해라면){
			if(현재 경로가 최적해라면){
				solution<-path
			}
		}
		else{
			for(모든 도시 중에서 한 도시 v 선택){
				path<-다음 방문 도시로 v 추가
				TSP_BackTracking(path,solution)
			}
		}
	}
	return result
}

9.2 8퀸 문제(Eight queens puzzle)
8x8 크기의 체스판에 8개의 퀸을 놓는 문제.
수직, 수평, 대각선 방향으로 서로 다른 퀸을 놓을 수 없습니다. 퀸이 서로 공격하기 때문.
즉, 8개의 퀸이 서로 공격하지 않으면서 동시에 8개를 놓을 수 있는 위치가 어디인지를 알아내는 문제.
백트래킹을 이용하여 퀸을 놓을 수 있는 모든 경우를 확인하여 어떤 위치가 가능한지.
모든 경우의 수는 64C8가지, 알고리즘을 통해 하면 92개.
분기 한정법이 바로 문제가 커질 경우 상당한 시간이 걸린다는 백트래킹의 약점을 보완할 방법.

9.2.1백트래킹의 적용
4x4라고 생각.
0번 행에 첫 번째 퀸을 놓을 수 있는 경우는 4가지.
우리가 순회할 때 계산을 편리하게 하기 위해 0번 행부터 시작.
두 번째 퀸은 "모든 행에는 하나의 퀸이 놓여야 한다"에 따라 1번 행에 놓을 수 있습니다.
0100 0100 0100 0100
1000 0100 0010 0001
0000 0000 0000 0000
0000 0000 0000 0000
실패 실패  실패 성공
수평 혹은 대각선으로 만날 경우 퀸을 놓을 수 없습니다.

이미 두 번째 퀸을 놓을 수 없는 경우라면 이 경우를 기반으로 해서 더 이상 탐색할 필요가 없습니다.
분기 한정은 이처럼 해가 될 수 없는 것이 확실해 질 때 가지치기(Pruning)을 하여 잘라내 버리는 방법.
두 개의 퀸 위치가 (a,b), (c,d)라면 다음 조건을 만족할 때 잘라내야 합니다.
1)같은 행에 있다:a==c
2)같은 열에 있다:b==d
3)대각선에 있다:|a-c|==|b-d|
(0,1)-(1,3)-(2,0)-(3,2)로 하나의 해를 구했습니다.
또 다른 해를 찾기 위해 되돌아가서 길을 찾아야 합니다.

백트래킹 알고리즘의 의사코드
현재 행(row)에서 새로운 퀸을 놓으려고 시도합니다.
0번 열부터 (queenNum-1)번 열까지 새로운 퀸을 놓으려고 시도합니다.
queenNum:퀸의 개수 (solution:최적 경로(출력 파라미터))
row:새로운 퀸을 놓을 행의 위치
path:현재 퀸을 놓은 경로(입출력 파라미터)
NQueen_BackTracking(queenNum,row,path){
	for(모든 열 중에서 한 열 i를 선택){
		if(새로운 퀸을 (row,i) 위치에 놓는 것이 가지치기 조건을 만족하는가){
		}
		else{
			path<-새로운 퀸 위치 (row,i) 추가
			if(row가 마지막 행인가){
				현재 구한 퀸들의 위치를 출력
			}
			else{
				NQueen_BackTracking(queenNum,row+1,path)
			}
		}
	}
}
단, 위치 (row,i)에 새로운 퀸을 놓는 것이 가지치기 조건을 만족하는지 먼저 조사.
만약 가지치기 조건을 만족하면 함수를 종료하여 탐색을 마칩니다.
가지치기 조건을 만족하지 않는다면 계속 탐색을 해야 하기 때문에 새로 찾은 퀸의 위치를 path에 추가.
이때 현재 행 row가 마지막 행인지도 검사.
마지막 행이라면 완전한 해를 하나 찾은 경우이기 때문에 현재까지 구한 퀸들의 위치 정보를 출력하고 종료.
마지막 행이 아니라면, 다음 행에 새로운 퀸을 놓을 수 있도록 행에 1을 더하여 재귀적으로 호출.
최초로 퀸을 놓을 행(row)의 위치 값을 0으로 전달.

9.3미로 문제(Maze problem)
미로의 입구에서 출구까지의 경로를 찾는 문제.
  01234567
0 S 000000 
1 0      0
2 000 0000
3 000 0000
4 0      0
5 0 000000
6 0
7 0000000E
가로 8칸, 세로 8칸, 입구는 S, 출구는 E. 0은 벽. S에서 E까지 가는 경로를 구하는 문제.

9.3.1백트래킹의 적용
편의상 4x4라고 생각
미로에서는 위쪽, 오른쪽, 아래쪽, 왼쪽만 이동할 수 있습니다.
"길이 막히면 되돌아가서 다른 길로 간다"=>모든 통로를 방문함으로써 출구를 찾는 방법.
0000
S  E
0000
0000
라고 생각했을 때, 단순히 오른쪽으로 이동만 하면 출구 E를 찾을 수 있습니다.
위 아래에는 벽이 있어서 갈 수 없고 왼쪽은 이미 방문한 곳이기 때문에.
'길을 따라 이동한다'='갈수 없는 곳'의 조건을 검사한 후에 갈 수 있는 곳으로 이동.
또한, 통로인 경우 방문한 통로인지 아닌지에 대한 정보가 필요.
0000
-> 0
0 00
0 00
라면 오른쪽으로 가다가 막히고 이전위치로 가서 다른 길을 찾아 이동하게 됩니다.
길이 막혔다는 것은 현재 위치가 출구가 아니면 더 이상 이동할 수 있는 곳이 없다.
이전 위치에서 돌아가서 조사하고 없다면 더 이전 위치로 이동.
모든 길을 다 가보았는데도 출구를 만나지 못하는 것은 원래 그 미로에 출구가 없거나 출구로 가는 길이 없음.

백트래킹 알고리즘의 의사코드
maze:미로를 나타내는 2차원 배열
start:시작 위치
end:출구 위치
current:현재 위치
path:경로 저장(입출력)
처음 시작할 때에는 current가 출구 위치 start가 됨.
Maze_BackTracking(maze, start, end, current, path){
	maze<-현재 위치 current를 방문 처리
	path<-경로에 현재 위치 current를 추가
	if(현재 위치가 end인가){
		출구를 찾았기 때문에 현재 알고리즘을 종료
	}
	else{
		for(이동 가능한 위치 중에서 한 위치인 v를 선택){
			Maze_BackTracking(maze,start,end,v,path)
		}
	}
}




*/