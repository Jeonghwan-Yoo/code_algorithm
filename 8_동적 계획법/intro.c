/*
동적 계획법(Dynamic programming)
계획법:주어진 문제를 나누고 이를 해결한다.
동적:문제를 푸는 도중 단계별로 값을 변경시키는

동적 계획법도 주어진 문제를 작은 하위 문제로 나누고 각 하위 문제에 대한 답을 계산합니다.
단, 하나의 문제를 작은 부분 문제로 나눌 때 부분 문제를 재활용할 수 있도록 나눈다는 점이 다릅니다.

처음 만났을 때는 당연히 문제를 풀어야 합니다. 하지만, 다시 만났을 때 다시 푸는 것보다
풀었던 답을 저장해 두고 재활용하는 것이 효율적입니다.
다른말로 메모리제이션(Memorization)이라고도 합니다.

8.1피보나치 수열(Fibonacci sequence)로 알아보는 동적 계획법
fibonacci(n)=                            0, if n=0
            =                            1, if n=1
			=fibonacci(n-1)+fibonacci(n-2), if n>=1

피보나치 수열은 정의 자체가 순환적입니다. 이전 수열 2개의 합으로 값이 계산됩니다.
분할 정복 기법을 쉽게 적용해서 재귀 호출 방식으로 구현할 수 있습니다.
아주 간단한 대신 성능 면에서는 매우 비효율적입니다. 수열 계산이 중복하여 여러 번발생하기 때문.
      6
     / \
    5   4
   / \  |\
  4   3 3 2
 / \
3   2
   / \
  1   0
시간 복잡도는 O(2^n)

이를 해결하는 법은 계산된 결과를 저장해 두는 것입니다.
그리고 두 번째 호출부터는 저장해 둔 결과를 재사용하는 것
즉, 중복 호출 자체를 없애는 것이 아니라 중복해서 계산하는 과정을 없애는 것.
메모이제이션은 이전에 계산한 값을 메모리에 저장함으로써 같은 계산이 반복되는 것을 제거하는 방법
동적 계획법을 적용하면 시간 복잡도가 O(n)입니다.
입력 파라미터 n의 크기에 비례하여 선형적으로 시간이 증가합니다.

동적 계획법은 주로 '최적 부분 구조(Optimal substructure)'라는 특징이 있는 문제에 적용.
최적해 속에는 부분 문제의 최적해가 포함되어 있습니다.
메모리제이션 기법을 사용하여 중복 호출 시에 발생하는 시간 문제를 해결합니다.
1차원 배열에 기존에 계산한 결과값을 저장하고 이를 바로 이용하는 방법이었습니다.

8.2동전 거스름돈 문제
거스름돈을 만들더라도 가능한 한 동전 개수가 적으면 적을수록 좋습니다.
현재 동전만을 사용한다면 탐욕 알고리즘도 항상 최적해를 구합니다.
하지만, 70원짜리 동전이 추가되면 최적해를 만족하지 않을 수 있습니다.
하지만 동적 계획법은 어떤 경우든 최적해를 계산할 수 있습니다.

8.2.1분할 정복법의 적용과 구현
사실 대부분의 동적 계획법은 분할 정복법으로 문제를 먼저 해결한 뒤에 동적 계획법을 적용할지 고려합니다.
해결 개념 자체는 거의 비슷하기 때문입니다.
분할 정복법으로 먼저 해결한 후 중복 호출 문제가 심각하다면 추가로 동적 계획법을 고려
 
예로 동전 10원, 70원, 100원짜리가 있고 거슬러 주어야 할 돈은 140원입니다.
      140
  10/70|  \100
 130  70  40
즉, 거스름돈이 130원, 70원, 40원인 3개의 하위 문제로 나누어졌습니다.
분할 정복 문제는 더 이상 쪼갤 수 없을 때까지 문제를 나눕니다.
      70
  10/70|  \100
  60   0   X

정복을 해보면 70원 문제의 최소 동전 개수는 1개가 되고 130원 40원은 4개가 됩니다.
140원에 대해서는 70원인 경우에 70원 동전 1개를 더해 동전 개수 2개로 최적해가 됩니다.

동전을 종류별로 1개씩 사용하여 하위 문제로 분할합니다.
쪼개진 하위 문제에서 최소 동전 개수를 구하고 거기에 1개를 더하면 됩니다.

C(n)은 거스름돈이 n원일 때 최소 동전 개수를 나타낼 때, C(n)=min(1<=k<=K){C(n-dk)+1}
동전의 종류는 모두 K개 만큼 있습니다. dk는 동전 k의 금액입니다.
인덱스 k가 1,2,3이라면 d1은 10, d2는 70 d3은 100입니다.
C(n)은 i번째 동전을 1개 사용하여 쪼개진 하위 문제 중에서 최소값에 1을 더한 값.
i번째 동전을 1개 사용하여 쪼개진 하위 문제를 C(n-dk).
최소 동전 개수는 쪼개진 하위 문제에서 구한 동전 개수에서 가장 작은 동전 개수를 구하고 거기에 1을 더함.

8.2.2동전 계획법의 적용
동적 계획법의 핵심은 하위 문제의 해답을 메모리에 저장해 두고 재활용한다는 것입니다.
거스름돈   0 1 ... 10 ... 20 ... 130 ... 140
최종해     0 1     1      2       4       2

시작하는 지점은 거스름돈이 가장 작은 값 1원부터 시작합니다.
1원씩 증가시켜 가면서 문제의 크기를 키웁니다.

분할 정복법은 현재 거스름돈 n에 대한 최소 동전 개수는 i번째 동전을 1개씩 사용하여 쪼개진 하위 문제 
중에서 최솟값을 이용합니다.
위에서 아래로(Top-Down) 내려가면서 문제를 해결하는 방식.
큰 문제를 동전의 종류를 하나씩 사용하면서 더 작은 문제로 내려갔습니다.

동적계획법은 아래에서 위로(Bottom-Up) 올라가는 방식입니다.
가장 작은 하위 문제(거스름돈 1원)에서 시작하여 점점 문제를 키우면서(1원씩) 최적해를 구하는 방법.
거스름돈이 69원에서 70원 될 때, 10원짜리를 생각하면 6->7이 됩니다.
70원짜리를 이용하면 0->1개가 됩니다. 100원짜리 동전은 사용할 수 없습니다.

동적 계획법은 아래에서 위로 올라가는 방식으로 하위 문제의 최적해를 기반으로 상위 문제의 최적해를 구함.
특별히 동전의 종류 별로 기존 하위 문제들을 찾아서 현재 금액의 최적해를 찾습니다.
즉, 현재 거스름돈에서 현재 선택된 동전의 금액을 뺀 만큼의 금액에 해당하는 하위 문제를 선택합니다.
기존 하위 문제들의 최적해를 메모리에 저장해 두기 때문에 바로 사용할 수 있습니다.

동적 계획법의 의사코드
change_total:거스름돈의 전체 금액
coins:동전들의 정보
CoinChange_DP(change_total,coins){
	TotalCount[change_total+1] //각 거스름돈의 전체 최소 동전 개수
	for(i:1원 부터 change_total원까지 1원씩 증가){
		min<-INT_MAX
		for(Coins의 모든 요소 k){
			dk<-동전 k의 금액
			if(dk<=i&&min>TotalCount[i-dk]+1){
				min<-TotalCount[i-dk]+1
			}
		}
		TotalCount[i]<-min
	}
	return TotalCount[change_total];
}
거스름돈 i가 1원부터 시작하여 change_total원에 이르기까지 1원씩 증가시키면서 최소 동전 개수를 구합니다.
                          <-------------------
거스름돈     ...      i-dk        ...          i         ...
TotalCount  ... TotalCount[i-dk] ... TotalCount[i-dk]+1 ...
현재 거스름돈 i에서 현재 선택된 동전의 금액 dk만큼을 뺀 금액에 해당하는 하위 문제를 선택합니다.
이 경우 TotalCount[i-dk]에 바로 하위 문제의 최적해가 저장되어 있습니다.
현재 거스름돈 i에 대한 최적의 동전 개수는 TotalCount[i-dk]+1입니다.
기존 하위 문제의 동전 개수에서 1개 더 추가되었습니다.
이렇게 구한 하위 문제의 최적해 중에서 가장 최소 동전 개수를 선택하여 임시 변수 min에 저장.

8.3 0-1 배낭 문제
배낭 문제는 배낭에 어떻게 물건을 담을지 결정하는 문제.
제로-원 냅색 혹은 영-일 배낭 문제는 하나의 짐을 온전히 담거나 아예 담을 수 없습니다.
0은 짐을 싣지 않는다는 뜻이며 1은 하나의 온전한 짐을 싣는다는 뜻.
이런 제약사항이 주어졌을 때 가방에 담긴 짐의 가치가 최대가 되도록 물건을 선택하는 문제.
부분 배낭 문제에서는 탐욕 알고리즘이 항상 최적해를 계산하지만 0-1에서는 항상 최적해를 찾을 수 없습니다.

8.3.1 분할 정복법의 적용과 구현
예로 용량이 5kg인 배낭,
A:1kg, 600원, 600(원/kg)
B:2kg, 1000원, 500(원/kg)
C:3kg, 1200원, 400(원/kg)
탐욕 알고리즘을 선택한다면 가치/무게 비율이 높은 물건을 선택하는 것이 맞습니다.
하지만, 0-1 배낭 문제의 최적해를 계산할 수 없습니다.
분할 정복법을 적용해보면, 3가지 물건을 각각 선택했을 때를 기준으로 문제를 쪼갭니다.
먼저 C를 선택하거나 안할 수 있습니다.
  5
 / \-3kg, +1200원
5   2
분할 정복 문제는 더 이상 쪼갤 하위 문제가 없을 때까지 문제를 나눕니다.
  5
 / \-3kg, +1200원
5   2
   / \-2kg, +1000원
  2   0
B를 싣지 않는다면 다시 하위 문제로 더 쪼갤 수 있습니다.
분할된 내용을 가지고 정복을 해보겠습니다.
    2
   / \-2kg, +1000원
  2   0
   \-1kg, +600원
    1
B를 선택했을 때 최대 가치는 1000원인 반면 아닐 때는 600원입니다. 따라서 B를 선택합니다.
  5
 / \-3kg, +1200원
5   2
각 하위 문제의 최대 가치는 각각 1600원, 1000원입니다.
C를 선택하지 않으면 1600원이지만 선택하면 2200원이됩니다. 그러므로 최적해는 2200원입니다.

정리해보면, 먼저, 물건별로 선택하거나 선택하지 않는 2가지 하위 문제로 분할합니다.
쪼개진 문제에서 구한 최대 가치에 현재 물건의 가치를 같이 고려하여 최적해를 구합니다.
식으로 정리해보면 K(i,w)=max{K(i-1,w), K(i-1,w-wi)+vi}
K(i,w)는 배낭 용량이 w고 물건의 수가 i개일 때 최대 가치를 말합니다.
배낭의 용량이 5kg이고 물건의 개수가 3개면 K(3,5)로 표기.
i번째 물건의 무게는 wi, 물건의 가치는 vi로 나타냄.
현재 배낭 용량이 w이고 물건 i까지 고려해서 최대 가치가 무엇인지를 K(i,w)로 나타냅니다.
물건 i를 선택했을 때의 최대 가치와 물건 i를 선택하지 않았을 때의 최대 가치 중에서 더 큰 값을 선택.
i를 선택하지 않았다면 배낭 용량은 그대로 유지하면서 물건의 개수가 1개 감소 K(i-1,w)
반대로 물건 i를 선택했다면 물건 i의 가치 vi만큼 가치가 증가한 대신 배낭의 용량은 물건 i의
무게 wi만큼 감소. 이때 최대 가치는 K(i-1,w-wi)+vi
결국 이 2가지 경우 중에서 더 큰 값을 선택하면 최적 가치 값.

8.3.2 동전 계획법의 적용
동적 계획법의 핵심은 하위 문제의 해답을 메모리에 저장해 두고 재활용한다는 것.
배낭의 용량을 1kg부터 증가시키면서 각 물건의 선택 여부를 저장해야 합니다.
각 물건을 별도로 저장해야 합니다. 왜냐하면, 물건의 종류 또한 1개부터 차례로 증가시켜야 해서.
2차원 배열이 필요합니다.
             배 낭 용 량 w
        1    2    3    4    5
A      시작
A,B
A,B,C                      최종
최종적으로 구해야 할 부분은 5행 3열.
배낭 용량이 5kg이라면 배낭 용량 w가 5이고 물건의 종류 i가 3가지(A,B,C)인 경우
배낭에 담긴 물건들의 가치가 최대가 되려면 어떤 물건들이 포함되어야 하는지를 구해야 합니다.
1kg에서 시작해서 1kg씩 증가시키면서 문제의 크기를 키웁니다. 가짓수도 1가지에서 1개씩 증가.

분할정복법에서 K(i,w)=max{K(i-1,w), K(i-1,w-wi)+vi}
결국 i번째 물건의 선택 여부에 따라 2개의 하위 문제로 쪼개졌으며 재귀적으로 호출하고 있습니다.
위에서 아래로 내려가면서 문제를 해결하는 방식.
큰 문제를 i번째 물건을 선택하거나 혹은 선택하지 않음으로써 더 작은 문제로 내려갔습니다.

동적계획법은 아래에서 위로 올라가는 방식.
가장 작은 하위 문제(1kg, 1가지)에서 시작하여 점점 문제를 키워가면서 최적해를 구하는 방법.
배낭의 용량 1kg씩 물건의 개수 1개씩 증가시키면서 최적해를 구해야 합니다.
하위 문제의 최적해를 기반으로 상위 문제의 최적해를 구합니다.
배낭 용량과 물건 2가지 요소를 모두 고려해야 합니다.
이 문제를 해결하는 힌트는 물건 C를 선택하거나 선택하지 않는 2가지 경우가 있다는 사실입니다.
C를 선택하지 않은 경우 물건의 종류가 A,B일 때의 배낭 가치와 같습니다.
이 경우 1600을 그대로 사용 => K(i-1,w)
C를 선택했을 때는 아직 물건 C가 추가된 상태가 아니기 때문에 물건 종류 A와 B일 때 배낭 가치를 사용.
K(i-1,w-wi)에 해당. wi는 3kg. 여기에 C의 가치 vi 1200이 더해져 2200이 됩니다.

8.4편집 거리 문제(Edit distance problem)
최소 편집 거리(Minimum edit distance) 혹은 리벤슈타인 거리(Levenshtein distance)는
문자열 두 개가 얼마만큼 다른지를 나타내는 문자열 측정 단위(String metric)입니다.
예로 Sunday와 Saturday는 서로 다른 문자열이고 서로 다른 문자는 3개입니다. (n, at, r)
편집 거리를 3이고 이처럼 두 개의 문자열이 다르다고 할 때 얼마만큼 다른지를 숫자로 나타냅니다.
편집 거리를 사용하는 대표적 경우는 맞춤범 검사기(Spell Checker)가 있습니다.
맞춤법 검사기는 사전에 없는 단어를 발견했을 때 기존의 단어를 기준으로 어떤 단어를 잘못 입력한 것인지 판단.
보통 편집 거리가 작을수록 우선순위가 더 높습니다.
편집 거리가 작을수록 두 개의 무자열이 더 비슷하다는 뜻.

편집거리는 생물 정보 공학(Bio-Informatics) 분야에서도 많이 사용.
주로 두 개의 유전자 사이의 유사도를 측정하는 데 편집 거리를 사용합니다.
두 개의 유전자가 얼마나 비슷한지를 측정할 때 편집 거리를 사용.

편집 거리 계산에 사용하는 연산의 종류
구분              내용              예    비고
삽입(Insertion)   추가된 문자가 있음 a-ab  b가 추가됨
삭제(Deletion)    삭제된 문자가 있음 ab-a  b가 삭제됨
치환(Substitution)변경된 문자가 있음 ab-ac a가 b로 치환됨

서로 다른 2개의 문자열이 주어졌을 때 기존 문자열에 연산을 이용해서 비교 문자열이 되었다고 가정.
그러면 비교 문자열과 같이 달라지도록 '연산'이 필요할 것.
편집 거리 계산에서는 기준이 되는 문자열에서 새로운 문자를 삽입하거나 삭제하거나 치환해 다른 문자열로.
분할 정복법 혹은 동적 계획법을 이용하여 편집 거리를 계산한다는 것은 최소 변경 연산 횟수를 구하는 것.
Sunday 문자열에서 S와 u사이에 문자 a와 t를 삽입하고 n을 r로 치환하면 Saturday

8.4.1분할 정복법의 적용과 구현
재귀 호출 기법을 이용합니다.
예로 abc와 ebd.
분할 정복법은 일단 두 문자열의 마지막 문자부터 비교를 시작.
abc의 마지막 문자는 c이며 ebd의 마지막 문자는 d => (3,3). 3번째에 있는 문자를 비교.
비교할 문자가 서로 다르기 때문에 편집 거리가 1증가.
다음 위치로 이동해서 문자열을 비교.
          abc, ebd 
	  (3,3)->편집거리 1
		/     |     \
    abc,eb ab,ebd  ab,eb
	(3,2)   (2,3)   (2,2)
먼저 비교 문자열 ebd의 비교 위치를 한 칸 왼쪽으로 이동시킬 수 있습니다.
(3,2)는 ebd의 비교 위치를 한 칸 왼쪽으로 이동시킨 것.
(2,3)은 abc의 비교 위치를 한 칸 왼쪽으로 이동시킨 것.
(2,2)은 기존 문자열과 비교 문자열 모두 한 칸씩 왼쪽으로 이동시킨 것.
비교 대상 문자열의 크기가 줄어들었다는 점이 공통점.
하나의 문제를 하위 문제 3개로 쪼갰다는 것을 알 수 있습니다.
3개의 하위 문제에서 최솟값을 구하고 여기에 1을 더하면 최소 편집 거리가 계산 될 것입니다.

정복을 해보겠습니다.
ab와 eb를 선택했을 때의 최소 편집 거리는 1입니다.
나머지는 최소 편집 거리가 2여서 ab/eb를 선택하는 것이 더 나은 선택.
현재 비교 문자 c와 d가 서로 다르기 때문에 하위 문제의 최소 편집 거리 1에 자신의 비교값 1을 더한 2.
더 이상 쪼갤 수 없는 하위 문제란 보통 한쪽 문자열이 먼저 끝난 경우.
비교 대상 문자열 중 한 문자열이 빈 문자열이라면 다른 문자열의 길이가 편집 거리가 됩니다.
비교 문자가 같으면 거리는 증가하지 않고 다음 위치로 이동해서 다시 문자열을 비교합니다.

정리해보면, 두 개의 비교 문자열에 대해서 현재 위치의 문자를 서로 비교합니다.
두 문자가 서로 같다면 두 문자열의 위치를 모두 한 칸씩 왼쪽으로 이동하여 비교를 계속합니다.
현재 위치의 문자가 서로 다르다면 하위 문제 중에서 최솟값을 구합니다.
기준 문자열만 이동, 비교 문자열만 이동, 두 문자열 모두 이동 중에서 최소 편집 거리를 구합니다.
현재 위치의 문자가 서로 다르기 때문에 1만큼 증가.

8.4.2동적 계획법의 적용
하위 문제의 해답을 메모리에 저장해 두고 재활용한다는 것.
이 경우 두 문자열의 길이가 각각 행과 열이 되는 2차원 배열이 필요.
   e   b   d
a 시작
b
c         최종
최종적으로 3행 3열을 구하는 것으로 abc와 ebd의 최소 편집 거리를 구하는 것.
시작하는 지점은 두 문자열의 시작 문자들.
그리고 비교 대상 문자열의 길이를 1씩 증가.
value(i,j)=min{value(i-1,j), value(i,j-1), value(i-1,j-1)}+1 단, string(i)!=string(j)
현재 비교 대상 문자(i,j)가 서로 다를 때 어떻게 편집 거리를 구하는지.
즉, 기존 하위 문자열 문제에서 최소 편집 거리를 선택한다는 것.
여기서 value(i,j)는 비교 대상 문자열의 길이가 각각 i와 j일 때의 편집 거리.
3가지 하위 문제에 대한 값 중에서 최솟값을 취하고 여기에 1을 더하면 됩니다.

하위 문제의 최적해를 기반으로 상위 문제의 최적해를 구합니다.
편집 거리 문제에서는 비교 대상이 되는 2개의 문자열 모두를 고려해야 합니다.
중요한 점은 기존의 3가지 하위 문제에서 구한 최솟값을 이용한다는 점입니다.
   e   b   d 
a
b      1   2  (b,b):(i-1,j-1) (b,d):(i-1,j)
c      2  +1  (c,b):(i,j-1)   (c,d):(i,j) 현재 문제.
여기서 하위 문제 중에서 최솟값 1을 선택하고 거기에 1을 더한 2가 됩니다.

만약 현재 비교 대상 문자(i,j)가 같다면 어떻게 구할까요?
value(i,j)=value(i-1,j-1), 단, string(i)==string(j)
기존 (i-1, j-1)의 해를 그대로 사용하면 됩니다.

동적계획법은 아래에서 위로 올라가는 방식으로, 하위 문제의 최적해를 기반으로 상위 문제의 최적해를 구함.
현재 비교 문자가 서로 다르다면 비교 문자열의 길이별로 하위 문제를 찾고 이중에서 최솟값을 이용하여 최적해.

동적 계획법과 그래프
플로이드 알고리즘의 기본 개념 "기존 경로(r->s)보다 새로 알게 된 경로(r->v->s)의 거리가
더 짧은지 점검하여 새로운 경로의 거리가 더 짧다면 이 경로가 새로운 최단 경로가 된다." 입니다.
for(v=0;v<nodeCount;v++){
	for(r=0;r<nodeCount;r++){
		for(s=0;r<nodeCount;s++){
			if(ppDistance[r][v]+ppDistance[v][s]<ppDistance[r][s]){
				ppDistance[r][s]=ppDistance[r][v]+ppDistance[v][s];
			}
		}
	}
}
부분 문제에 대한 답이 무엇인지 미리 저장해 둡니다.
그리고 다음에 다시 그 '부분 문제'를 만나면 기존에 계산된 결과값을 이용합니다.
(r->s)의 최적값을 ppDistance[r][s]에 저장.
또한, 기존 최적값을 각 중간 노드 v를 통해 가는 경로 ppDistance[r][v]+ppDistance[v][s]와 비교.

*/