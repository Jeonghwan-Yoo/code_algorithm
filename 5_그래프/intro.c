/*
그래프는 표현 능력이 가장 뛰어나다. 그래서 어떤 자료구조로 모델링한다면 가장 먼저 그래프로.
왜냐하면, 그래프는 노드와 간선을 이용하여 복잡한 현실 세계를 손쉽게 나타낼 수 있기 때문.
그래프에서는 노드가 어떠한 대상 혹은 사물을 나타내고 간선은 사물들의 관계를 표현합니다.

또한, 지도가 그래프 자료구조로 저장되어 있다면 여러 가지 알고리즘을 적용할 수 있습니다.
최단 경로 알고리즘은 출발점에서 도착점까지 가장 빨리 갈 수 있는 경로를 찾는 알고리즘입니다.
여러 분야에서 다양하게 사용되고, 내비게이션도 내부적으로는 최단 경로 알고리즘을 이용합니다.

5.1그래프 자료구조
먼저 지도 정보가 필요합니다. 정거장과 정거장 사이를 연결하는 도로 정보가 있어야 합니다.
정거장 사이의 거리일 수 있고 아니면 도로를 이동하는 데 걸리는 시간일 수 있습니다.
이러한 정보를 이용하여 가장 짧은 거리를 구합니다.

그래프는 노드(Node)와 간선(Edge)의 집합을 말합니다.
노드란 리스트 또는 트리와 마찬가지로 저장하려는 자료의 단위. 정점(Vertex)라고도 합니다.
간선은 노드 사이를 연결하는 선을 말합니다.
간선에 방향이 있는 그래프를 방향 그래프 없는 그래프는 무방향 그래프입니다.
방향성이 없는 간선이란 사실 방향성이 있는 간선 2개를 합친 것. 양쪽가능
그래프의 각 간선에 있는 가중치(Weight)라는 속성을 이용하면 간선에 추가적인 정보를 저장할 수 있습니다.

그래프 자료구조를 구현하는 방법은 크게 2가지입니다.
인접 행렬(Adjacency Matrix)와 인접 리스트(Adjacency List).
인접 행렬은 간선 정보를 2차원 배열 형태로 저장하는 방법이며, 인접 리스트는 간선 정보를 연결 리스트로.

5.2최단 경로 구하기
최단 경로(Shortest path)는 주어진 두 노드 사이의 경로 중에서 최소 비용 또는 최소 시간으로 이동할
수 있는 경로를 말합니다.
출발하는 곳에서 시작하여 도착하는 곳까지 갈 수 있는 길을 경로라고 합니다. 보통 여러개.
그래프의 경로란 시작 노드부터 도착 노드까지 간선들이 연결된 것.

경로를 수학적으로 표현하려면 경로에 있는 노드들을 나열해야 한다.
즉, 노드 A에서 노드 B에 이르는 간선들의 인접 노드를 순서대로 나열한 리스트.
그래프의 간선에는 노드 사이의 거리 정보를 저장할 수 있습니다.
따라서 최단 경로를 구하는 데 필요한 자료 구조는 가중 그래프(Weighted graph)가 됩니다.
최단 경로 알고리즘은 가중 그래프를 이용하여 최단 경로를 구합니다.

5.2.1하나의 시작점에서 구하기:Dikstra(다잌스트라) 알고리즘
가장 먼저 살펴볼 문제는 경로 탐색을 시작하는 지점, 즉 시작점이 1개인 경우입니다.
시작하는 노드를 먼저 정하면 나머지 다른 노드들이 도착점이 됩니다.
노드 사이의 거리가 모두 0보다 큰 양수일 때는 다잌스트라 알고리즘을 널리 사용합니다.
가중치가 양수인 그래프를 대상으로, 하나의 시작점을 기준으로 나머지 노드 사이의 최단 경로를 구하는 알고리즘.

일반적인 경우는 아니지만, 모델링하는 시스템에 따라 노드 사이의 가중치가 음수인 경우도 있습니다.
가중치가 음수인 그래프에서는 다잌스트라 알고리즘을 사용할 수 없습니다.

5.2.1.1기본 개념
다잌스트라 알고리즘은 "지름길을 이용하라"입니다. 가장 쉽고 빠른 길을 말합니다.
시간이 적게 걸리는 "새로 알게 된 지름길"을 이용한다는 것이 기본 개념.
다잌스트라 알고리즘은 기존에 알고 있는 지름길을 연장해서 새로운 길을 찾습니다.
물론 다잌스트라 알고리즘이 제시하는 새로운 길이 기존에 알고 있는 길보다 거리가 더 멀 수도 있습니다.
그래서 기존의 지름길과 비교해서 거리가 더 짧아졌는지 비교해야만 합니다.

다잌스트라 알고리즘은 기존에 알고 있던 최단 경로(지름길)에 새로운 간선을 추가하는 방식으로
새로운 길을 찾고 거리를 비교하여 지름길을 찾아냅니다.
다잌스트라 알고리즘에서는 간선의 가중치 값이 양수라고 가정하기 때문에 가능합니다. 음수면 X

5.2.1.2의사코드(pseudo code)
알고리즘의 개념을 간결하게 나타내는 데 사용하는 약어.

먼저 시작 노드는 r,도착 노드는 w로 지정. 시작 노드 r부터 도착 노드 w까지 걸리는 거리를 Yw라고 합시다.
노드 v와 노드 w사이의 거리는 Cv,w입니다.
1)(기존의 지름길 선택)시작 노드 r에서 최단 거리를 알고 있는 노드 v를 선택합니다.
2)(새로운 길 찾기)최단 거리 노드 v와 연결된 노드 w를 찾아서 새로운 경로를 찾습니다.
3)(새로운 길의 거리 평가 및 적용)만약 노드 w를 이용한 새로운 길이 기존에 알던 길보다 거리가
더 짧다면 노드 w의 경로를 변경합니다. 

Yw=Yv+Cv,w , if Yv+Cv,w<Yw

                       Yv
				 v<-----------r
				  \          /
			   Cv,w\        /Yw
					\>  w  /
최단 거리를 이미 알고 있는 노드 v와 노드 w를 연결한 새로운 길이 지름길인지 점검합니다.
노드 v와 노드 w를 연결한 길의 총 거리는 Yv+Cv,w입니다.이 값과 기존에 걸리던 거리 Yw를 비교합니다.
기존에 알고 있던 거리 Yw보다 노드 v에서 간선 (v,w)를 연결한 새로운 경로가 더 짧다면 노드 w의 경로를 수정

다잌스트라 알고리즘은 시작점이 1개일 때 최단 경로를 구하는 알고리즘입니다.
그래프의 노드 개수가 n개라면 연산을 최대 (n-1)번 실행해서 다른 모든 노드를 이용한 최단 경로를 구합니다.

step0
1)집합 S초기화 S=V(G)
2)시작 노드 r에서 다른 노드 w 사이의 거리(Yw) 초기화
노드 r과 연결되지 않은 노드들의 거리는 모두 oo(무한대)로 설정한다.
step1
1)집합 S 중에서 최단 거리인 노드 Yv를 찾아 S에서 제거
2)노드 v에 인접한 노드 w에 대해서 다음 조건 검사 및 값 변경 실시
Yw = Yv + Cvw ,if Yv + Cvw < Yw(단, 노드 w는 S에 포함된 노드다.)
step2
집합 S에 있는 모든 노드를 제거할 때까지 step1을 반복.(n-1)번 만큼

다잌스트라 알고리즘은 기존에 최단 경로를 알고 있는 노드를 대상으로, 인접한 다른 노드의 최단경로를 점검
이러한 반복 과정 전에 먼저 초기화 단계인 step0을 거칩니다. step1과 step2루프를 돕니다.
집합 S는 step1과 step2의 처리 대상이 되는 노드를 모아둔 집합입니다.
step1에 들어갈 때마다 노드를 하나씩 제거합니다.
새로운 지름길을 알아야 하기 때문에 가장 시간이 적게 걸리는 노드를 선택합니다.
집합 S에서 더 이상 꺼낼 노드가 없다면 알고리즘이 끝납니다.

5.2.1.3알고리즘 실행의 예
0->1(2) 1->2(1) 2->0(4) 3->2(5) 4->5(3) 5->3(6)
 ->2(4)          ->3(7)  ->4(2)
                         ->5(6)

step0
집합(S) 도착노드(v) 거리(Yv)       시작노드 0
  1       1          2(min)      무한대는 모르는 값이나 연결되어 있지 않은 값
  2       2          4           
  3       3          oo          
  4       4          oo          
  5       5          oo           

step1
집합(S) 도착노드(v) 기존거리 변경된거리(Yv)   
          1          2(min)    -              최단 거리를 가지는 노드는 1, 1을 S에서 제거
  2       2          4         3         노드 1과 연결되어있을 뿐만 아니라 집합S에 포함되어야 한다.
  3       3          oo        -              이미 최단 거리를 구한 노드를 다시 계산하지 않기 위해.
  4       4          oo        -              4>1+2
  5       5          oo        -

step2
S에 4개, 시작 노드에서 가장 거리가 짧은 노드는 2

step1
집합(S) 도착노드(v) 기존거리 변경된거리(Yv)     
          1          2         -              최단 거리를 알고 있는 노드 2를 S에서 제거.    
		  2          3(min)    -               3+7<oo
  3       3          oo        10             
  4       4          oo        -             
  5       5          oo        -            

step2
S에 3개, 시작 노드에서 가장 거리가 짧은 노드는 3

step1
집합(S) 도착노드(v) 기존거리 변경된거리(Yv)
          1          2         -                최단 거리를 알고 있는 노드 3을 S에서 제거.
          2          3         -                10+2<oo
          3          10(min)   -                10+6<oo
  4       4          oo        12
  5       5          oo        16

step2
S에 2개, 시작 노드에서 가장 거리가 짧은 노드는 4

step1
집합(S) 도착노드(v) 기존거리 변경된거리(Yv)     최단 거리를 알고 있는 노드 4을 S에서 제거.
          1          2         -                12+3<16
		  2          3         -                
		  3          10        -                 
		  4          12(min)   -              
  5		  5          16        15                

step2
S에 1개, 시작 노드에서 가장 거리가 짧은 노드는 5

step1
최단 거리를 알고 있는 노드 5를 S에서 제거.

step2
S에 노드가 없으므로 종료.

결과
도착노드(v) 거리(Yv)  이전연결노드
    1         2           0
	2         3           1
	3         10          2
	4         12          3
	5         15          4
이전 연결 노드를 따라가면 결국 최단 경로가 됩니다.
그래프에 n개의 노드가 있다고 가정하면 다잌스트라 시간 복잡도는 O(n^2)입니다.
(n-1)번의 루프를 도는 동안 내부적으로 2n번의 루프를 돌기 때문입니다.

최단 경로 문제의 종류
1)단일 시작점에서 최단 경로 구하기
가장 기본이 되는 문제. 시작점이 하나인 경우.
시작 노드를 정해 놓고 나머지 노드 사이의 최단 경로를 구하는 문제.
2)모든 최단 경로 구하기
시작점도 그래프의 모든 노드에 속하는 경우. 예)플로이드 알고리즘
3)도달 가능성 문제
하나의 시작 노드에서 다른 노드 사이에 경로가 있는지를 판단하는 문제.
만약 경로가 있따면 시작 노드에서 출발하여 무사히 도착할 수 있습니다.
반면, 중간에 끊어진 곳이 있어서 도착할 수 없다면 영원히 도착할 수 없습니다.

5.2.2모든 시작점에서 경로 구하기:Floyd(플로이드) 알고리즘
기본적으로 다익스트라 알고리즘과 접근방법이 같습니다.
"새로 알게 된 지름길"이 있는지 확인하여 반복적으로 최단 경로를 수정.
다만, 시작 노드가 1개가 아니라 여러개.

5.2.2.1기본개념
"최단 경로를 수정하는 전략"이라는 점에서 같습니다. 
시작 노드 r에서 도착 노드 s까지의 최단 거리를 구하기 위해 중간에 있는 노드 v를 이용합니다.
새로운 경로의 거리가 더 짧다면 이 경로가 새로운 최단 경로가 됩니다.
플로이드 알고리즘은 그래프의 모든 노드가 시작노드가 된다는 점이 다릅니다.
시작노드가 r뿐만아니라 v, s가 될 수 있습니다. 또한 모든 노드가 도착노드가 될 수 있습니다.

예) 0->1(2)  1->2(1)  2->0(4)
     ->2(4)
	         도착노드
	시작노드  0  1  2
	   0     0  2  4
	   1     oo 0  1
	   2     4  oo 0

행과 열이 각각 시작 노드와 도착 노드를 의미하는 2차원 배열이 플로이드 알고리즘이 사용하는 주요 자료구조.
플로이드 알고리즘을 실행하면 2차원 배열의 빈 부분이 채워집니다.
플로이드 알고리즘은 그래프의 모든 노드에 대해서 "중간노드"로 최단 경로를 만드는 데 사용할 수 있는지 점검
노드 0부터 2까지 모두 3개의 노드가 중간 노드가 되었을 때 지름길을 만드는 데 사용할 수 있는지 확인.
플로이드 알고리즘에서는 3중 루프를 돌면서 그래프의 모든 노드가 각각 중간 노드, 시작 노드, 도착 노드가
된 경우를 계산해 최단 경로를 구합니다.

플로이드 알고리즘은 새로운 지름길을 찾을 수 있는 모든 경우를 조사합니다.
중간 노드, 시작 노드, 도착 노드의 조합을 말합ㄴ디ㅏ.
각 조합이 기존 경로보다 거리를 단축시킨다면 새로운 경로로 변경합니다.

5.2.2.2의사코드
for(v:그래프 G의 모든 노드)
	for(r:그래프 G의 모든 노드)
		for(s:그래프 G의 모든 노드)
			if(Yr,v + Cv,s < Yr,s)         Yr,v:노드 r부터 노드 s까지의 거리
				Yr,s = Yr,v + Cv,s         Cv,s:노드 v와 노드 s사이의 거리
중간 노드 v에 그래프의 모든 노드를 하나씩 대입해가면서 루프를 돌 뿐만 아니라
시작 노드 r, 도착 노드 s도 그래프의 모든 노드를 대입합니다.

5.2.2.3알고리즘 실행의 예
===Step0 초기화
먼저 2차원 결과 배열을 초기화합니다.
서로 연결된 두 노드에는 해당 간선의 가중치로 초기화가 됩니다.

 0->1(2)  1->2(1)  2->0(4)
	 ->2(4)
		 도착노드
시작노드  0  1  2
   0     0  2  4
   1     oo 0  1
   2     4  oo 0

===노드 0인 중간 노드인 경우
         도착노드
시작노드  1  2
   1     0  1
   2     oo 0
2->1은 간선이 없기 때문에 거리는 oo입니다.
중간 노드 0을 이용하면 4+2=6입니다.
1->2은 1입니다.
중간 노드 0을 이용하면 oo+4=oo입니다.
		 도착노드
시작노드  0  1  2
   0     0  2  4
   1     oo 0  1
   2     4  6  0

==노드 1이 중간 노드v인 경우
         도착노드
시작노드  0  2
   0     0  4
   2     4  0
0->2은 4입니다.
중간 노드 1을 이용하면 2+1=3입니다.
2->0은 4입니다.
중간 노드 1을 이용하면 6+oo=oo입니다.
		 도착노드
시작노드  0  1  2
   0     0  2  3
   1     oo 0  1
   2     4  6  0

==노드 2이 중간 노드v인 경우
		 도착노드
시작노드  0  1
   0     0  2
   1     oo 0
0->1은 2입니다.
중간 노드 2을 이용하면 3+6=9입니다.
1->0은 oo입니다.
중간 노드 2을 이용하면 1+4=5입니다.
		 도착노드
시작노드  0  1  2
   0     0  2  3
   1     5  0  1
   2     4  6  0

플로이드 알고리즘은 노드 개수가 n개라고 했을 때 시간 복잡도가 O(n^3)입니다. 3중 반복문
아주 간결한 반복문으로 구현할 수 있기 때문에 모든 노드에 대한 최단 경로를 구할 때 이용.

5.2.3도달 가능성 구하기
도달 가능성이란 그래프의 한 노드에서 다른 노드로 이동할 수 있는 가능성을 말합니다.
두 노드가 직접 연결되어 있다면 쉽게 도달할 수 있는지 알수 있습니다.
반면, 바로 연결되어 있지 않다면 다른 노드를 거쳐서 가야 할 수도 있고,
경로가 없어서 도달할 수 없는 경우도 있습니다.

플로이드 알고리즘을 약간 변형하면 "도달 가능성 구하기"문제에도 적용할 수 있습니다.
거리 정보가 필요 없고 단지 연결 여부만 있으면 됩니다.
경로가 있다면 1로 설정하고 없다면 0으로 설정합니다.

초기화
그래프G의 모든 r,s에 대해 2차원 배열 A초기화
A^-1[r][s]=1, r과 s사이에 간선이 존재
A^-1[r][s]=0, r과 s사이에 간선이 존재X
루프
for(v:그래프 G의 모든 노드)
	for(r:그래프 G의 모든 노드)
		if(A^(v-1)[r][v]>0)
			for(s:그래프 G의 모든 노드)
				if(A^(v-1)[v][s]>0)
					A^v[r][s]=1
A는 그래프의 시작 노드와 도착 노드 사이의 연결 정보를 저장합니다.
[시작 노드 id][종료 노드 id]는 해당 경로의 유무를 나타냅니다.
초깃값은 각 노드를 직접 연결하는 간선이 있다는 뜻입니다.
행렬에 대한 위첨자는 최단 경로 계산에 사용하는 중간 노드를 나타냅니다.
A^v는 v를 중간 노드로 이용하여 최단 경로를 구한것
A^(v-1)은 v를 사용하지 않고 최단 경로를 구한것.

그래프 G의 모든 노드 r에서 노드 s까지의 경로가 있는 상태를 이행적 폐쇄(Transitive closure)라고 합니다.

5.3최소 비용 신장 트리
기존 그래프에서 불필요한 간선을 제거해서 트리를 만들었다.

5.3.1신장 트리란?
신장 트리는 그래프의 모든 노드 V를 포함하는 트리를 말합니다.
신장(Spanning)은 모든 노드를 포함한다는 뜻입니다.
신장 트리는 트리의 한 종류라는 점이 중요합니다.
그래서 그래프가 가지고 있는 간선을 모두 사용할 필요가 없습니다.
트리이기 때문에 "순환(Cycle)"이 없어야 합니다.
만약 그래프에 4개의 노드가 있다면 신장 트리는 3개의 간선만 있으면 됩니다.
신장 트리는 기존 그래프가 가진 모든 노드를 순환 없이 서로 연결한 트리.
트리의 노드 개수가 n개라면 트리의 간선 개수는 n-1개입니다.

5.3.2최소 비용 신장 트리란?
최소 비용 신장 트리(Minimum cost spanning tree)는 가중 그래프를 기반으로 구할 수 있습니다.
간선을 어떻게 연결하느냐에 따라서 가중치를 합한 값에 차이가 발생합니다.
그래서 가중 그래프의 신장 트리 중에서 가중치의 합이 최소인 신장 트리를 말합니다.

5.3.3크루스칼(Kruskal) 알고리즘
크루스칼 알고리즘은 비용이 적은 간선부터 하나씩 선택하여 신장 트리를 만들어 가는 알고리즘.
그래프의 모든 간선을 비용 순으로 정렬한 다음 가중치 값이 작은 간선부터 차례대로 선택하여
신장 트리를 완성해 갑니다.

5.3.3.1기본 개념
그래프 G에서 불필요한 간선을 제거하여 최소 비용 신장 트리 H를 만드는 것입니다.
크루스칼 알고리즘은 간선이 전혀 없는 상태에서 간선을 하나씩 추가하는 방법을 사용합니다.

그래프에서 노드만 두고 간선을 모두 제거합니다. 제거한 간선은 가중치 값으로 정렬합니다.
가중치 값이 적은 간선부터 하나씩 추가합니다. 가장 작은 간선이 1개 이상이면 아무거나 먼저해도 무관.
하지만, 단순히 가중치 값에 따라서 간선을 선택하기만 해서는 안됩니다.
추가로 순환을 일으키지 않는 "최소 가중치" 간선을 선택해야 합니다.

즉,크루스칼 알고리즘에서는 간선을 점검하여 순환을 발생시키지 않는 "가중치가 가장 작은 간선"을 선택.
이러한 과정을 그래프의 모든 노드가 연결될 때까지 반복하면 최소 비용 신장 트리를 만들 수 있습니다.

5.3.3.2의사코드
입력 파라미터로 그래프 G를 전달 받습니다.
step-0 초기화
(1)그래프 G의 최소 비용 신장 트리 H를 다음과 같이 초기화한다.
H=(V(G), E(H)) 단, E(H)=0
(2)그래프 G의 모든 간선을 가중치 값에 따라 오름차순으로 정렬한다.
step-1 루프
정렬된 간선 중 가중치가 가장 작으면서, 순환을 발생시키지 않는 간선 e를 추출.
step-2 루프
그래프 G의 모든 노드가 연결될 때까지 step-1을 반복.

신장 트리 H는 간선의 집합이 0으로 아무 간선도 없습니다.
다만, 그래프 G의 모든 간선 E(G)를 가중치 값에 따라 오름차순으로 정렬해 놓습니다.
이후 크루스칼 알고리즘은 루프를 돌면서 조건에 맞는 간선을 하나씩 추가합니다.
모든 노드가 연결되면 종료.

5.3.3.3알고리즘 실행의 예
Step0 초기화
간선을 오름차순으로 정렬.
(2,3) 1, (3,4) 1, (1,2) 2, (0,2) 3, (0,1) 4, (3,5) 5, (4,5) 6

Step1
가장 작은 (2,3)을 선택
Step2
노드 6개가 안되므로 다시 수행
Step1
가장 작은 (3,4)을 선택
Step2
노드 6개가 안되므로 다시 수행
Step1
가장 작은 (1,2)을 선택
Step2
노드 6개가 안되므로 다시 수행
Step1
가장 작은 (0,2)을 선택
Step2
노드 6개가 안되므로 다시 수행
Step1
가장 작은 (0,1)을 선택하지만 순환이 발생하서 버리고 (3,5)를 선택
Step2
노드 6개이므로 완성. 총 비용은 12로 최솟값.

5.3.4프림(Prim) 알고리즘
프림 알고리즘은 트리를 확장시켜 가면서 최소 비용 신장 트리를 만드는 방법.
일단 시작 노드 1개만 먼저 추가합니다. 
그런다음 현재 추가한 노드와 연결된 간선 중에서 가중치가 가장 작은 간선을 추가합니다.
중요한 점은 "현재 추가한 노드와 연결된" 간선 중에서 선택한다는 점.
간선뿐만 아니라 간선에 연결된 노드도 같이 추가합니다.

5.3.4.1기본 개념
입력값도 가중 그래프 G입니다.
그래프 G에서 불필요한 간선을 제거하여 최소 비용 신장 트리 H를 만드는 방식은 같습니다.
단, 프림 알고리즘은 먼저 그래프에서 노드 1개를 선택합니다.

그리고 나서 현재 신장 트리에 연결된 간선 중에서 가중치가 가장 작은 간선을 선택합니다.
간선 뿐만아니라 노드도 같이 추가합니다.
"현재 신장 트리"를 확장하는 느낌.
프림 알고리즘에서는 순환이 발생하는 간선인지 점검하여 "가중치가 가장 작은 간선"을 선택합니다.
그래프의 모든 노드가 연결될 때까지 반복합니다.

5.3.4.2의사코드
프림 알고리즘은 입력 파라미터로 그래프 G를 받습니다.
초기화
그래프 G에서 임의의 시작 노드 r을 선택하여 신장 트리 T를 초기화
V(T)={r}  E(T)=0(아직 선택된 간선은 없다)
Step-1(루프)
V(t)와 연결된 모든 간선 중에서 가장 가중치가 작으면서 순환을 발생시키지 않는 간선을 선택하여 T를 확장
E(T)=E(T)U{e}, e:추가되는 최소 가중치 간선
V(T)=V(T)U{w}, w:e와 부속된 노드로 ,V(T)에 포함되지 않던 노드.
Step-2(루프)
그래프 G의 모든 노드가 V(T)에 포함될 때까지 Step-1을 반복.

5.3.4.3알고리즘 실행의 예
0<->1(4) 0<->2(3) 1<->2(2) 2<->3(1) 3<->4(1) 3<->5(5) 4<->5(6)
  4
1---0
2\ /3
  2
  1\1
4---3
6\ /5
  5
Step-0 초기화
입력 파라미터인 그래프 G3에서 시작 노드를 1개 선택합니다. 예로 1을 선택.
선택된 간선:없음
선택된 노드:1

Step-1
1은 0과 2로 연결되어 있습니다.이 중에서 가장 가중치가 작은 (1,2)가 선택됩니다.
노드2는 아직 "현재 신장 트리"에 포함되지 않았습니다. 따라서 2를 추가합니다.
선택된 간선:(1,2)
선택된 노드:1,2

Step-2
G3의 노드 개수 6보다 작아서 Step-1을 다시 실행합니다.

Step-1
2는 0과 1과 3으로 연결되어 있습니다.이 중에서 가장 가중치가 작은 (2,3)가 선택됩니다.
노드2는 아직 "현재 신장 트리"에 포함되지 않았습니다. 따라서 3을 추가합니다.
선택된 간선:(1,2) (2,3)
선택된 노드:1,2,3

Step-2
G3의 노드 개수 6보다 작아서 Step-1을 다시 실행합니다.

Step-1
선택된 노드의 연결된 간선은 (0,1) (0,2) (3,4) (3,5)있고 가장 가중치가 작은 (3,4)가 선택됩니다.
노드4는 아직 "현재 신장 트리"에 포함되지 않았습니다. 따라서 4를 추가합니다.
선택된 간선:(1,2) (2,3) (3,4)
선택된 노드:1,2,3,4

Step-2
G3의 노드 개수 6보다 작아서 Step-1을 다시 실행합니다.

Step-1
선택된 노드의 연결된 간선은 (0,1) (0,2) (3,5) (4,5)있고 가장 가중치가 작은 (0,2)가 선택됩니다.
노드0는 아직 "현재 신장 트리"에 포함되지 않았습니다. 따라서 0을 추가합니다.
선택된 간선:(1,2) (2,3) (3,4) (0,2)
선택된 노드:1,2,3,4,0

Step-2
G3의 노드 개수 6보다 작아서 Step-1을 다시 실행합니다.

Step-1
선택된 노드의 연결된 간선은 (0,1) (3,5) (4,5)있고 가장 가중치가 작은 (0,1)가 선택됩니다.
그러나 (0,1)을 추가하면 순환이 발생합니다. 그다음 작은 (3,5)를 선택합니다.
노드5는 아직 "현재 신장 트리"에 포함되지 않았습니다. 따라서 5를 추가합니다.
선택된 간선:(1,2) (2,3) (3,4) (0,2) (3,5)
선택된 노드:1,2,3,4,0,5

Step-2
G3의 노드 개수 6과 같아서 종료합니다.
총 비용은 12로 최솟값입니다.

크루스칼트리와 간선을 구한 순서는 다르지만, 같은 최소 비용 신장 트리입니다.


*/